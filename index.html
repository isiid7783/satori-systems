<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
html,body{
margin:0;
padding:0;
width:100%;
height:100%;
background:black;
overflow:hidden;
}
#overlay{
position:fixed;
inset:0;
display:flex;
align-items:center;
justify-content:center;
color:white;
font-family:monospace;
z-index:10;
}
</style>
</head>
<body>

<div id="overlay">tap to begin</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.min.js"></script>
<script>
/* ===== 起動 ===== */
const overlay = document.getElementById("overlay");

/* ===== ランダム人格 ===== */
const seed = Math.random();
let profile = {
calmThreshold: 0.7 + seed*0.25,
noiseDecay: 0.97 + seed*0.02,
audioBase: 40 + seed*80
};

/* ===== Three.js ===== */
let scene,camera,renderer,mesh;

/* ===== Motion ===== */
let motionHistory=[];
let gyroHistory=[];
let lastInteraction=performance.now();
let calmIndex=0;
let calmDuration=0;
const HISTORY=60;

/* ===== Audio ===== */
let audioCtx,osc,gain;

overlay.onclick = async ()=>{
if(typeof DeviceMotionEvent!=="undefined" &&
typeof DeviceMotionEvent.requestPermission==="function"){
const p = await DeviceMotionEvent.requestPermission();
if(p!=="granted") return;
}
overlay.remove();
init3D();
initAudio();
window.addEventListener("devicemotion",onMotion);
animate();
};

/* ===== 初期化 ===== */
function init3D(){
scene=new THREE.Scene();
camera=new THREE.PerspectiveCamera(60,innerWidth/innerHeight,0.1,100);
camera.position.z=3;

renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

const geo=new THREE.IcosahedronGeometry(1,3);
const mat=new THREE.MeshStandardMaterial({
color:0xffffff,roughness:0.5,metalness:0.1
});
mesh=new THREE.Mesh(geo,mat);
scene.add(mesh);

const light=new THREE.DirectionalLight(0xffffff,1);
light.position.set(2,2,2);
scene.add(light);

addEventListener("resize",()=>{
camera.aspect=innerWidth/innerHeight;
camera.updateProjectionMatrix();
renderer.setSize(innerWidth,innerHeight);
});
}

function initAudio(){
audioCtx=new (window.AudioContext||window.webkitAudioContext)();
osc=audioCtx.createOscillator();
gain=audioCtx.createGain();
osc.type="sine";
osc.frequency.value=profile.audioBase;
gain.gain.value=0;
osc.connect(gain);
gain.connect(audioCtx.destination);
osc.start();
}

/* ===== 観測 ===== */
["touchstart","touchmove","click"].forEach(e=>{
addEventListener(e,()=>lastInteraction=performance.now());
});

function onMotion(e){
const a=e.accelerationIncludingGravity;
const r=e.rotationRate;
if(!a||!r) return;

motionHistory.push(Math.sqrt(a.x*a.x+a.y*a.y+a.z*a.z));
gyroHistory.push(Math.sqrt(r.alpha*r.alpha+r.beta*r.beta+r.gamma*r.gamma));

if(motionHistory.length>HISTORY) motionHistory.shift();
if(gyroHistory.length>HISTORY) gyroHistory.shift();
}

function variance(arr){
const m=arr.reduce((a,b)=>a+b,0)/arr.length;
return arr.reduce((a,b)=>a+(b-m)*(b-m),0)/arr.length;
}

/* ===== ループ ===== */
let lastTime=performance.now();
function animate(){
requestAnimationFrame(animate);
const now=performance.now();
const dt=now-lastTime;
lastTime=now;

if(motionHistory.length>=HISTORY){
const mv=variance(motionHistory);
const gv=variance(gyroHistory);
const inactivity=Math.min((now-lastInteraction)/2000,1);

calmIndex=
0.4*Math.max(0,1-mv*5)+
0.4*Math.max(0,1-gv*5)+
0.2*inactivity;

if(calmIndex>profile.calmThreshold){
calmDuration+=dt;
}else{
calmDuration=Math.max(0,calmDuration-dt*0.5);
}

if(calmDuration>3000){
calmDuration=0;
profile.calmThreshold=0.6+Math.random()*0.4;
profile.noiseDecay=0.97+Math.random()*0.02;
profile.audioBase=30+Math.random()*120;
}
}

const instability=1-calmIndex;

mesh.rotation.x+=0.002+instability*0.01;
mesh.rotation.y+=0.003+instability*0.01;
mesh.scale.setScalar(1+instability*0.2);
mesh.material.roughness=
mesh.material.roughness*profile.noiseDecay+instability*0.05;

if(gain){
const target=calmIndex>0.85?0:Math.min(instability*0.15,0.15);
gain.gain.linearRampToValueAtTime(
target,audioCtx.currentTime+0.1
);
osc.frequency.value=profile.audioBase+instability*60;
}

renderer.render(scene,camera);
}
</script>
</body>
</html>
