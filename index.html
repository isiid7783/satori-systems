<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
html,body{
margin:0;
padding:0;
width:100%;
height:100%;
background:black;
overflow:hidden;
}
#overlay{
position:fixed;
inset:0;
display:flex;
align-items:center;
justify-content:center;
color:white;
font-family:monospace;
z-index:10;
}
</style>
</head>
<body>

<div id="overlay">tap to begin</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.min.js"></script>
<script>
const overlay=document.getElementById("overlay");

let scene,camera,renderer,mesh;
let motion=[],gyro=[];
let lastInteraction=performance.now();
let calmIndex=0,calmTime=0;
const HISTORY=60;

const seed=Math.random();
let phase={
calmThreshold:0.7+seed*0.2,
noiseDecay:0.97+seed*0.02,
audioBase:40+seed*80
};

let audioCtx,osc,gain;

overlay.onclick=async()=>{
if(typeof DeviceMotionEvent!=="undefined" &&
typeof DeviceMotionEvent.requestPermission==="function"){
const p=await DeviceMotionEvent.requestPermission();
if(p!=="granted")return;
}
overlay.remove();
init3D();
initAudio();
window.addEventListener("devicemotion",onMotion);
animate();
};

["touchstart","touchmove","click"].forEach(e=>{
addEventListener(e,()=>lastInteraction=performance.now());
});

function init3D(){
scene=new THREE.Scene();
camera=new THREE.PerspectiveCamera(60,innerWidth/innerHeight,0.1,100);
camera.position.z=3;

renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

const geo=new THREE.IcosahedronGeometry(1,3);
const mat=new THREE.MeshStandardMaterial({
color:0xffffff,roughness:0.5,metalness:0.1
});
mesh=new THREE.Mesh(geo,mat);
scene.add(mesh);

const light=new THREE.DirectionalLight(0xffffff,1);
light.position.set(2,2,2);
scene.add(light);

addEventListener("resize",()=>{
camera.aspect=innerWidth/innerHeight;
camera.updateProjectionMatrix();
renderer.setSize(innerWidth,innerHeight);
});
}

function initAudio(){
audioCtx=new (window.AudioContext||window.webkitAudioContext)();
osc=audioCtx.createOscillator();
gain=audioCtx.createGain();
osc.type="sine";
osc.frequency.value=phase.audioBase;
gain.gain.value=0;
osc.connect(gain);
gain.connect(audioCtx.destination);
osc.start();
}

function onMotion(e){
const a=e.accelerationIncludingGravity;
const r=e.rotationRate;
if(!a||!r)return;

motion.push(Math.sqrt(a.x*a.x+a.y*a.y+a.z*a.z));
gyro.push(Math.sqrt(r.alpha*r.alpha+r.beta*r.beta+r.gamma*r.gamma));
if(motion.length>HISTORY)motion.shift();
if(gyro.length>HISTORY)gyro.shift();
}

function variance(arr){
const m=arr.reduce((a,b)=>a+b,0)/arr.length;
return arr.reduce((a,b)=>a+(b-m)*(b-m),0)/arr.length;
}

let last=performance.now();
function animate(){
requestAnimationFrame(animate);
const now=performance.now();
const dt=now-last;
last=now;

if(motion.length>=HISTORY){
const mv=variance(motion);
const gv=variance(gyro);
const inactivity=Math.min((now-lastInteraction)/2000,1);
calmIndex=
0.4*Math.max(0,1-mv*5)+
0.4*Math.max(0,1-gv*5)+
0.2*inactivity;

if(calmIndex>phase.calmThreshold){
calmTime+=dt;
}else{
calmTime=Math.max(0,calmTime-dt*0.5);
}

if(calmTime>3000){
calmTime=0;
phase.calmThreshold=0.6+Math.random()*0.4;
phase.noiseDecay=0.97+Math.random()*0.02;
phase.audioBase=30+Math.random()*120;
}
}

const instability=1-calmIndex;

mesh.rotation.x+=0.002+instability*0.01;
mesh.rotation.y+=0.003+instability*0.01;
mesh.scale.setScalar(1+instability*0.2);
mesh.material.roughness=
mesh.material.roughness*phase.noiseDecay+instability*0.05;

if(gain){
const t=calmIndex>0.85?0:Math.min(instability*0.15,0.15);
gain.gain.linearRampToValueAtTime(t,audioCtx.currentTime+0.1);
osc.frequency.value=phase.audioBase+instability*60;
}

renderer.render(scene,camera);
}
</script>
</body>
</html>
